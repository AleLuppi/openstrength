<template>
  <q-table
    :columns="columns"
    :rows="rows"
    flat
    dense
    wrap-cells
    separator="cell"
    bordered
    :pagination="{ rowsPerPage: 0 }"
    :hide-header="!props.headers || props.headers instanceof Array"
    :hide-bottom="true"
    row-key="row"
    @mouseup="onSelectionEnd"
    @mouseleave="onSelectionEnd"
    @copy.prevent="onCopy"
    @paste.prevent="onPaste"
  >
    <!-- Set header style -->
    <template v-slot:header="props">
      <q-tr :props="props" class="bg-table-header">
        <q-th
          v-for="col in props.cols"
          :key="col.name"
          :props="props"
          class="text-h6 text-table-header text-uppercase text-weight-medium"
        >
          {{ col.label }}
        </q-th>
      </q-tr>
    </template>

    <!-- Set custom rows -->
    <template v-slot:body="props">
      <q-tr
        :props="props"
        @click="($attrs.onRowClick as Function)?.(undefined, props.row)"
        :class="{
          'cursor-pointer': $attrs.onRowClick || props.row.expanded,
        }"
        class="os-tr-selected"
      >
        <q-td
          v-for="col in props.cols"
          :key="col.name"
          :props="props"
          :class="{
            'os-td-selected': isSelected(props.row.id, col.id),
          }"
          @click="
            if (getCellName(props.row.id, col.id) in childElements)
              childElements[getCellName(props.row.id, col.id)]?.focus();
          "
          @mousedown="onSelectionStart(props.row.id, col.id)"
          @mouseover="onSelectionContinue(props.row.id, col.id)"
        >
          <q-input
            :ref="
              (el) => (childElements[getCellName(props.row.id, col.id)] = el)
            "
            :model-value="(modelValue[props.rowIndex] ?? newRow)[col.name]"
            @update:model-value="
              (value) => onModelValueUpdate(props.rowIndex, col.name, value)
            "
            borderless
            autogrow
            :dense="dense"
          ></q-input>
        </q-td>
      </q-tr>
    </template>
  </q-table>
</template>

<script setup lang="ts">
import { ref, computed, PropType } from "vue";

// Define props
const props = defineProps({
  modelValue: {
    type: Array as PropType<{ [key: string]: string }[]>,
    required: true,
  },
  headers: {
    type: [Array, Object] as PropType<string[] | { [key: string]: string }>,
    required: false,
  },
  showNewLine: {
    type: Boolean,
    default: false,
  },
  dense: {
    type: Boolean,
    default: false,
  },
});

// Update model values to parent
const emit = defineEmits<{
  "update:modelValue": [value: { [key: string]: string }[]];
}>();

// Set ref
const childElements = ref<{ [key: string]: any }>({});
const selected = ref<{
  rowFrom: number;
  rowTo: number;
  colFrom: number;
  colTo: number;
}>();
const isSelecting = ref(false);

// Get headers map
const headers = computed(() => {
  console.log(props.headers, props.headers && props.headers instanceof Object);
  if (props.headers) {
    if (props.headers instanceof Array)
      return props.headers.reduce(
        (obj: { [key: string]: string }, val) => ({ ...obj, [val]: val }),
        {},
      );
    else return props.headers;
  }
  return props.modelValue.reduce(
    (outHeaders: { [key: string]: string }, row) => (
      Object.keys(row).forEach((col) => {
        if (!(col in outHeaders)) outHeaders[col] = col;
      }),
      outHeaders
    ),
    {},
  );
});

// Set rows and columns
const columns = computed(() =>
  Object.entries(headers.value).map(([key, val], index) => ({
    id: getCellName(undefined, index),
    name: key,
    field: key,
    label: val,
  })),
);
const rows = computed(() =>
  [...props.modelValue, ...(props.showNewLine ? [newRow.value] : [])].map(
    (row, rowIndex) => ({
      id: getCellName(rowIndex),
      ...row,
    }),
  ),
);

// Set an empty new line
const newRow = computed(() =>
  columns.value.reduce((out, col) => ({ ...out, [col.name]: "" }), {}),
);

/**
 * Update the value of a selected cell and emit the update.
 *
 * @param rowId row id from where update request is occurring.
 * @param colId column id from where update request is occurring.
 * @param newValue value that shall be inserted in selected cell.
 */
function onModelValueUpdate(
  rowId: number,
  colId: string,
  newValue: string | number | null,
) {
  // Get a copy of current data
  const outValue = props.modelValue;

  // Add a new line if necessary
  if (rowId == outValue.length && String(newValue).trim()) {
    outValue[rowId] = {};
  }

  // Update with new value
  if (newValue != null && rowId < outValue.length) {
    outValue[rowId][colId] = String(newValue);
    emit("update:modelValue", outValue);
  }
}

/**
 * Get the name of a cell based on its location in the grid.
 *
 * @param rowNum row number.
 * @param colNum column number.
 * @returns cell name.
 */
function getCellName(rowNum?: string | number, colNum?: string | number) {
  const nameList = [];
  if (rowNum !== undefined) nameList.push(rowNum);
  if (colNum !== undefined) nameList.push(colNum);
  return nameList.join(".");
}

/**
 * Get the header name according to column number.
 *
 * @param colNum column number whose header should be retrieved.
 * @returns header name.
 */
function getHeaderName(colNum: number) {
  return columns.value[colNum].name;
}

/**
 * Start cells selection by selecting current cell only.
 *
 * @param rowNum row number of current cell that's being selected.
 * @param colNum column number of current cell that's being selected.
 */
function onSelectionStart(rowNum: string | number, colNum: string | number) {
  isSelecting.value = true;
  selected.value = {
    rowFrom: Number(rowNum),
    rowTo: Number(rowNum),
    colFrom: Number(colNum),
    colTo: Number(colNum),
  };
}

/**
 * Add current cell to the selection in rectangular format.
 *
 * @param rowNum row number of current cell that's being selected.
 * @param colNum column number of current cell that's being selected.
 */
function onSelectionContinue(rowNum: string | number, colNum: string | number) {
  if (isSelecting.value)
    if (selected.value) {
      selected.value.rowTo = Number(rowNum);
      selected.value.colTo = Number(colNum);
    } else onSelectionStart(rowNum, colNum);
}

/**
 * Stop cells selection.
 */
function onSelectionEnd() {
  isSelecting.value = false;
}

/**
 * Check if a cell is in selection.
 *
 * @param rowNum row number of cell to check.
 * @param colNum column number of cell to check.
 * @returns true if cell is selected, false otherwise.
 */
function isSelected(rowNum: string | number, colNum: string | number) {
  if (!selected.value) return false;
  const numRow = Number(rowNum),
    numCol = Number(colNum);
  return (
    numRow >= Math.min(selected.value.rowFrom, selected.value.rowTo) &&
    numRow <= Math.max(selected.value.rowFrom, selected.value.rowTo) &&
    numCol >= Math.min(selected.value.colFrom, selected.value.colTo) &&
    numCol <= Math.max(selected.value.colFrom, selected.value.colTo)
  );
}

/**
 * Override copy to save data to clipboard.
 *
 * @param clipboardEvent event that triggered copy.
 */
function onCopy(clipboardEvent: ClipboardEvent) {
  // Ensure some data are selected
  if (!selected.value) return;

  // Get starting and ending values in order
  const rowStart = Math.min(selected.value?.rowFrom, selected.value?.rowTo),
    rowEnd = Math.max(selected.value?.rowFrom, selected.value?.rowTo),
    colStart = Math.min(selected.value?.colFrom, selected.value?.colTo),
    colEnd = Math.max(selected.value?.colFrom, selected.value?.colTo);

  // Prepare text to copy
  const rowData = [];
  const colData = [];
  for (let row = rowStart; row <= rowEnd; row++) {
    colData.length = 0;
    for (let col = colStart; col <= colEnd; col++) {
      colData.push(props.modelValue[row][getHeaderName(col)]);
    }
    rowData.push(colData.join("\t"));
  }

  // Copy text
  clipboardEvent.clipboardData?.setData("text/plain", rowData.join("\n"));
}

/**
 * Override paste to get data from clipboard.
 *
 * @param clipboardEvent event that triggered paste.
 */
function onPaste(clipboardEvent: ClipboardEvent) {
  // Ensure one cell is selected
  if (!selected.value) return;

  // Get starting cell
  const rowStart = Math.min(selected.value?.rowFrom, selected.value?.rowTo),
    colStart = Math.min(selected.value?.colFrom, selected.value?.colTo);

  // Replace data in table with input
  clipboardEvent.clipboardData
    ?.getData("text/plain")
    .split(/\r?\n/)
    .forEach((rowData, rowIndex) =>
      rowData.split(/\t/).forEach((colData, colIndex) => {
        onModelValueUpdate(
          rowStart + rowIndex,
          getHeaderName(colStart + colIndex),
          colData,
        );
      }),
    );
}
</script>

<style scoped lang="scss">
.os-tr-selected {
  & > .os-td-selected {
    background: rgba($primary, 0.1);
    border: 1px solid $primary;
  }
}
</style>
